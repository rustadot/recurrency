# Capacity Staking Rewards Implementation

## Overview
This document describes a new type of staking which allows token holders to stake FRQCY and split staking rewards with a Provider the staker chooses. 

Currently, when staking token for Capacity, the only choice is to assign all the generated Capacity to the designated target.  
The target, who must be a Provider, may then spend this Capacity to pay for specific transactions.  This is called **Maximized Capacity** staking.

In this new type of staking, called **Provider Boosting**, the Provider receives a reward in Capacity and the staker receives a periodic return in FRQCY token.
The amount of Capacity that the Provider would receive in such case is a less than what they would get from a `MaximumCapacity` stake.

The period of Capacity replenishment - the `Epoch` - and the period of token reward - the `RewardEra`- are different. 
Epochs much necessarily be much shorter than rewards because Capacity replenishment needs to be multiple times a day to meet the needs of a high traffic network, and to allow Providers the ability to delay transactions to a time of day with lower network activity if necessary. 
Reward eras need to be on a much longer scale, such as every two weeks, because there are  potentially orders of magnitude more stakers, and calculating rewards is computationally more intensive than updating Capacity balances for the comparatively few Providers.
In addition, this lets the chain to store Reward history for much longer rather than forcing people to have to take steps to claim rewards.

### Diagram
This illustrates roughly -- not to scale and **NOT reflecting actual reward amounts** -- how Provider Boost staking is expected to work.  Just like the current staking behavior, now called Maximium staking, The Capacity generated by staking is added to the Provider's Capacity ledger immediately so it can be used right away. The amount staked is locked in Alice's account, preventing transfer.

Provider Boost token rewards are earned only for token staked for a complete Reward Era.  So Alice does not begin earning rewards until Reward Era 5 in the diagram, and this means Alice must wait until Reward Era 6 to claim rewards for Reward Era 5.  Unclaimed reward amounts are actually not minted or transferred until they are claimed, and may also not be calculated until then, depending on the economic model.

This process will be described in more detail in the Economic Model Design Document.

### NOTE: Actual reward amounts are TBD; amounts are for illustration purposes only
![Provider boosted staking](https://github.com/LibertyDSNP/frequency/assets/502640/ffb632f2-79c2-4a09-a906-e4de02e4f348)

The proposed feature is a design for staking FRQCY token in exchange for Capacity and/or FRQCY.
It is specific to the Frequency Substrate parachain.
It consists of enhancements to the capacity pallet, needed traits and their implementations, and needed runtime configuration.

This does _not_ outline the economic model for Staking Rewards (also known as "Provider Boosting"); it describes the economic model as a black box, i.e. an interface.

## Context and Scope:
The Frequency Transaction Payment system allows certain transactions on chain to be paid for with Capacity.  Accounts that wish to pay with Capacity must:

1. Have an [MSA](https://github.com/LibertyDSNP/frequency/blob/main/designdocs/accounts.md)
2. Be a [Provider](https://github.com/LibertyDSNP/frequency/blob/main/designdocs/provider_registration.md) (see also [Provider Permissions and Grants](https://github.com/LibertyDSNP/frequency/blob/main/designdocs/provider_permissions.md))
3. Stake a minimum amount of FRQCY (on mainnet, UNIT on Rococo testnet) token to receive [Capacity](https://github.com/LibertyDSNP/frequency/blob/main/designdocs/capacity.md).

# Problem Statement
This document outlines how to implement the Staking for Rewards feature described in [Capacity Staking Rewards Economic Model (TBD)](TBD).
It does not give regard to what the economic model actually is, since that is yet to be determined.

## Glossary
1. **FRQCY**: the native token of Frequency, a Substrate parachain in the Polkdaot blockhain ecosystem.
1. **Capacity**: the non-transferrable utility token which can be used only to pay for certain Frequency transactions.
1. **Account**: a Frequency System Account controlled by a private key and addressed by a public key, having at least a minimum balance (currently 0.01 FRQCY).
1. **Stake** (verb): to lock some amount of a token against transfer for a period of time in exchange for some reward.
1. **RewardEra**: the time period (TBD in blocks) that Staking Rewards are based upon. `RewardEra` is to distinguish it easily from Substrate's staking pallet Era, or the index of said time period.
1. **Staking Reward**: a per-RewardEra share of a staking reward pool of FRQCY tokens for a given staking account.
1. **Reward Pool**: a fixed amount of FRQCY that can be minted for rewards each RewardEra and distributed to stakers.
1. **StakingRewardsProvider**: a trait that encapsulates the economic model for staking rewards, providing functionality for calculating the reward pool and staking rewards.

## Staking Token Rewards

### StakingAccountDetails --> StakingDetails
New fields are added. The field **`last_rewarded_at`** is to keep track of the last time rewards were claimed for this Staking Account.
MaximumCapacity staking accounts MUST always have the value `None` for `last_rewarded_at`. 

This is a second version of this storage, to replace StakingAccountDetails, and StakingAccountDetails data will need to be migrated.
```rust
pub struct StakingDetails<T: Config> {
    pub active: BalanceOf<T>,
    pub last_rewards_claimed_at: Option<T::RewardEra>, // NEW  None means never rewarded, Some(RewardEra) means last rewarded RewardEra.
}
```

### StakingTargetDetails updates, StakingHistory
A new field, `staking_type` is added to indicate the type of staking the Account holder is doing in relation to this target.
Staking type may be `MaximumCapacity` or `ProviderBoost`. `MaximumCapacity` is the default value for `staking_type` and maps to 0.

```rust
/// A per-reward-era record for StakingAccount total_staked amount.
pub struct StakingHistory<Balance, RewardEra> { // NEW
    total_staked: Balance,
    reward_era: RewardEra,
}

#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct StakingTargetDetails<T: Config> {
	/// The total amount of tokens that have been targeted to the MSA.
	pub amount: BalanceOf<T>,
	/// The total Capacity that an MSA received.
	pub capacity: BalanceOf<T>,
	/// The type of staking, which determines ultimate capacity per staked token.
	pub staking_type: StakingType, // NEW
    /// total staked amounts for each past era, up to StakingRewardsPastErasMax eras.
    pub staking_history: BoundedVec<StakingHistory<BalanceOf<T>, T::RewardEra>, T::StakingRewardsPastErasMax>, // NEW
}
```

**Unstaking thaw period**
Changes the thaw period to begin at the first block of next RewardEra instead of immediately.

### Changes to extrinsics
#### stake
The parameters for the `stake` extrinsic remain the same and the behavior is the same, in that this creates or adds
more token to a staker-target relationship with type `MaximiumCapacity`.
However, if one calls `stake` with a `target` that `origin` already has a staker-target relationsip with, 
it is _not_ a `MaximumCapacity` staking type, it will error with `Error::CannotChangeStakingType`. 

#### unstake
The unstake parameters are the same, and unstake behavior is the same for `MaximumCapacity` as before, however 
for a `ProviderBoost` staker-target relationship, the behavior must be different.  While it's not feasible to
store either `reward_pool` history or individual staking reward history indefinitely, it still may be lengthy
enough that having to calculate _all_ unclaimed rewards for what could be numerous accounts in one block
could make a block heavier than desired.  Therefore there must be a limit limit on how many eras
one can claim rewards for. This value will likely be a pallet constant.  The logic would be:

 * If a ProviderBoost stake is `payout_eligible`, 
   * check whether their last payout era is recent enough to pay out all rewards at once.
   * if so, first pay out all rewards and then continue with rest of unstaking code as is 
   * if not, emit error `MustFirstClaimRewards`, `UnclaimedRewardsOverTooManyEras` or something like that.
       Don't use `EraOutOfRange` because it will overload the meaning of that error; needs to be something more specific.
 * If not payout eligible, 
   * check whether the last payout era is the current one. 
     * if so, all rewards have been claimed, so continue with rest of unstaking code as is, 
     * if not, it means they have too many unlocking chunks so they'll have to wait. - the unstaking code
         will catch this anyway and emit `MaxUnlockingChunksExceeded`

```rust
pub fn unstake(
    origin: OriginFor<T>,
    target: MessageSourceId,
    requested_amount: BalanceOf<T>,
) -> DispatchResult {}

```
### NEW: StakingRewardsProvider - Economic Model trait
This one is not yet determined, however there are certain functions that will definitely be needed.
The rewards system will still need to know the `reward_pool_size`.

The struct and method for claiming rewards is probably going to change.
The `staking_reward_total` for a given staker may not be calculable by the node, depending on the complexity of the 
economic rewards model. 
It's possible that it would be calculated via some app with access to the staker's wallet, and submitted as a proof
with a payload.
In that case the `validate_staking_reward_claim` is more likely to be part of the trait.

```rust
use std::hash::Hash;

pub struct StakingRewardClaim<T: Config> {
    /// How much is claimed, in token
    pub claimed_reward: Balance,
    /// The end state of the staking account if the operations are valid
    pub staking_account_end_state: StakingDetails,
    /// The starting era for the claimed reward period, inclusive
    pub from_era: T::RewardEra,
    /// The ending era for the claimed reward period, inclusive
    pub to_era: T::RewardEra,
}

pub trait StakingRewardsProvider<T: Config> {

    /// Calculate the size of the reward pool for the given era, in token
    fn reward_pool_size() -> BalanceOf<T>;

    /// Return the total unclaimed reward in token for `account_id` for `fromEra` --> `toEra`, inclusive
    /// Errors:
    ///     - EraOutOfRange when fromEra or toEra are prior to the history retention limit, or greater than the current RewardEra.
    /// May not be possible depending on economic model complexity.
    fn staking_reward_total(account_id: T::AccountId, fromEra: T::RewardEra, toEra: T::RewardEra);

    /// Validate a payout claim for `account_id`, using `proof` and the provided `payload` StakingRewardClaim.
    /// Returns whether the claim passes validation.  Accounts must first pass `payoutEligible` test.
    /// Errors: None
    fn validate_staking_reward_claim(account_id: T::AccountID, proof: Hash, payload: StakingRewardClaim<T>) -> bool;
}
```

### NEW: Config items
```rust
pub trait Config: frame_system::Config {
    // ...

    /// A period of `EraLength` blocks in which a Staking Pool applies and
    /// when Staking Rewards may be earned.
    type RewardEra:  Parameter
                + Member
                + MaybeSerializeDeserialize
                + MaybeDisplay
                + AtLeast32BitUnsigned
                + Default
                + Copy
                + sp_std::hash::Hash
                + MaxEncodedLen
                + TypeInfo;
    /// The number of blocks in a Staking RewardEra
    type EraLength: Get<u32>;
    /// The maximum number of eras over which one can claim rewards
    type StakingRewardsPastErasMax: Get<u32>;
    /// The trait providing the ProviderBoost economic model calculations and values
    type RewardsProvider: StakingRewardsProvider;
};
```

### NEW: RewardPoolInfo, RewardPoolHistory
Information about the reward pool for a given Reward Era and how it's stored. The size of this pool is limited to
`StakingRewardsPastErasMax` but is stored as a CountedStorageMap instead of a BoundedVec for performance reasons:
* claiming rewards for the entire history will be unlikely to be allowed. Iterating over a much smaller range is more performant
* Fetching/writing the entire history every block could affect block times. Instead, once per block, retrieve the latest record, delete the earliest record and insert a new one
```rust
pub struct RewardPoolInfo<Balance> {
    /// the total staked for rewards in the associated RewardEra
    pub total_staked_token: Balance,
    /// the reward pool for this era
    pub total_reward_pool: Balance,
    /// the remaining rewards balance to be claimed
    pub unclaimed_balance: Balance,
}

/// Reward Pool history
#[pallet::storage]
#[pallet::getter(fn get_reward_pool_for_era)]
pub type StakingRewardPool<T: Config> = <CountedStorageMap<_, Twox64Concat, RewardEra, RewardPoolInfo<T>;
```

### NEW: CurrentEra, RewardEraInfo
Incremented, like CurrentEpoch, tracks the current RewardEra number and the block when it started.
Storage is whitelisted because it's accessed every block and would improperly adversely impact all benchmarks.
```rust
#[pallet::storage]
#[pallet::whitelist_storage]
#[pallet::getter(fn get_current_era)]
/// Similar to CurrentEpoch
pub type CurrentEraInfo<T:Config> = StorageValue<_, T::RewardEraInfo, ValueQuery>;

pub struct RewardEraInfo<RewardEra, BlockNumber> {
    /// the index of this era
    pub current_era: RewardEra,
    /// the starting block of this era
    pub era_start: BlockNumber,
}
```

### NEW: Error enums
```rust
pub enum Error<T> {
    /// ...
    /// Staker tried to change StakingType on an existing account
    CannotChangeStakingType,
    /// The Era specified is too far in the past or is in the future
    EraOutOfRange,
    /// Rewards were already paid out for the specified Era range
    IneligibleForPayoutInEraRange,
    /// Attempted to retarget but from and to Provider MSA Ids were the same
    CannotRetargetToSameProvider,
    /// Rewards were already paid out this era
    AlreadyClaimedRewardsThisEra,
}
```

### NEW Extrinsics
This is the most undecided portion of this design and depends strongly on the chosen economic model for Provider Boosting.
There are generally two forms that claiming a staking reward could take, and this depends on whether it's possible to 
calculate rewards on chain at all.

Regardless, on success, the claimed rewards are minted and transferred as locked token to the origin, with the existing
unstaking thaw period for withdrawal (which simply unlocks thawed token amounts as before).
There is no chunk added; instead the existing unstaking thaw period is applied to last_rewards_claimed_at in StakingDetails.

Forcing stakers to wait a thaw period for every claim is an incentive to claim rewards sooner than later, leveling out
possible inflationary effects and helping prevent unclaimed rewards from expiring. 
The thaw period must be short enough for all rewards to be claimed before rewards history would end. 
Therefore, it's possible that a complete separate reward claim thaw period would need to be used.

For all forms of claim_staking_reward, the event `StakingRewardClaimed` is emitted with the parameters of the extrinsic.

#### provider_boost(origin, target, amount)
Like `stake`, except this extrinsic creates or adds staked token to a `ProviderBoost` type staker-target relationship.
In the case of an increase in stake, `staking_type` MUST be a `ProviderBoost` type, or else it will error with `Error::CannotChangeStakingType`.
```rust
pub fn provider_boost(
    origin: OriginFor<T>,
    target: MessageSourceId,
    amount: BalanceOf<T>,
) -> DispatchResult {}
```

#### 1. claim_staking_reward(origin, from_era, to_era), simple economic model
In the case of a simple economic model such as a fixed rate return, reward calculations may be done on chain - 
within discussed limits.
```rust
/// Claim staking rewards from `from_era` to `to_era`, inclusive.
/// from_era: if None, since last_reward_claimed_at
/// to_era: if None, to CurrentEra - 1
///  Errors:
///     - NotAStakingAccount:  if Origin does not own the StakingRewardDetails in the claim.
///     - IneligibleForPayoutInEraRange:  if rewards were already paid out in the provided RewardEra range
///     - EraOutOfRange: 
///         - if `from_era` is earlier than history storage
///         - if `to_era` is >= current era 
///         - if `to_era` - `from_era` > StakingRewardsPastErasMax
#[pallet::call_index(n)]
pub fn claim_staking_reward(
   origin: OriginFor<T>,
   from_era: Option<T::RewardEra>,
   to_era: Option<T::RewardEra>
);
```

#### 2. claim_staking_reward(origin,proof,payload)
TBD whether this is the form for claiming rewards.
This could be the form if calculations are done off chain and submitted for validation.

```rust
    /// Validates the reward claim. If validated, mints token and transfers to Origin.
    /// Errors:
    ///     - NotAStakingAccount:  if Origin does not own the StakingRewardDetails in the claim.
    ///     - StakingRewardClaimInvalid:  if validation of calculation fails
    ///     - IneligibleForPayoutInEraRange:  if rewards were already paid out in the provided RewardEra range
    ///     - EraOutOfRange: 
    ///         - if `from_era` is earlier than history storage
    ///         - if `to_era` is >= current era 
    ///         - if `to_era` - `from_era` > StakingRewardsPastErasMax
    #[pallet::call_index(n)]
    pub fn claim_staking_reward(
        origin: OriginFor<T>,
        /// `proof` - the Merkle proof for the reward claim
        proof: Hash,
        /// The staking reward claim payload for which the proof was generated
        payload: StakingRewardClaim<T>
    );
```
#### 3. change_staking_target(origin, from, to, amount)
Changes a staking account detail's target MSA Id to a new one by `amount`
Rules for this are similar to unstaking; if `amount` would leave less than the minimum staking  amount for the `from` target, the entire amount is retargeted.
No more than `T::MaxUnlockingChunks` staking amounts may be retargeted within this Thawing Period.
Each call creates one chunk.  Emits a `StakingTargetChanged` event with the parameters of the extrinsic.
```rust
/// Sets the target of the staking capacity to a new target.
/// This adds a chunk to `StakingDetails.stake_change_unlocking chunks`, up to `T::MaxUnlockingChunks`.
/// The staked amount and Capacity generated by `amount` originally targeted to the `from` MSA Id is reassigned to the `to` MSA Id.
/// Does not affect unstaking process or additional stake amounts.
/// Changing a staking target to a Provider when Origin has nothing staked them will retain the staking type.
/// Changing a staking target to a Provider when Origin has any amount staked to them will error if the staking types are not the same.
/// ### Errors
/// - [`Error::NotAStakingAccount`] if origin does not have a staking account
/// - [`Error::MaxUnlockingChunksExceeded`] if `stake_change_unlocking_chunks` == `T::MaxUnlockingChunks`
/// - [`Error::StakerTargetRelationshipNotFound`] if `from` is not a target for Origin's staking account.
/// - [`Error::StakingAmountBelowMinimum`] if `amount` to retarget is below the minimum staking amount.
/// - [`Error::InsufficientStakingBalance`] if `amount` to retarget exceeds what the staker has targeted to `from` MSA Id.
/// - [`Error::InvalidTarget`] if `to` does not belong to a registered Provider.
/// - [`Error::CannotChangeStakingType`] if origin already has funds staked for `to` and the staking type for `from` is different.
#[pallet:call_index(n+1)] // n = current call index in the pallet
pub fn change_staking_target(
    origin: OriginFor<T>,
    from: MessageSourceId,
    to: MessageSourceId,
    amount: BalanceOf<T>
);
```

### NEW:  Capacity pallet helper function
#### payout_eligible
Returns whether `account_id` can claim a reward at all. 
This function will return false if there is no staker-target relationship. 
Staking accounts may claim rewards:
* ONCE per RewardEra,
* Only for funds staked for a complete RewardEra, i.e. the balance at the end of the Era,
* Must wait for the thaw period to claim rewards again (see `last_rewards_claimed_at`)
```rust
fn payout_eligible(account_id: AccountIdOf<T>) -> bool;
```

### NEW RPCS
There are no custom RPCs for the Capacity pallet, so that work will need to be done first.

The form of this will depend on whether the rewards calculation for an individual account is done by the node or externally
with a submitted proof.  If externally, then unclaimed rewards would not include an earned amount.

```rust
pub struct UnclaimedRewardInfo {
    /// The Reward Era for which this reward was earned
    reward_era: RewardEra,
    /// An ISO8701 string, UTC, estimated using current block time, and the number of blocks between
    /// the current block and the block when this era's RewardPoolInfo would be removed from StakingRewardPool history 
    expires_at: string,
    /// The amount staked in this era
    staked_amount: BalanceOf<T>,
    /// The amount in token of the reward (only if it can be calculated using only on chain data)
    earned_amount: BalanceOf<T>
}

/// Check what unclaimed rewards origin has and how long they have left to claim them
/// If no unclaimed rewards, returns empty list.
fn check_for_unclaimed_rewards(origin: OriginFor<T>) -> Vec<UnclaimedRewardInfo>;
```
