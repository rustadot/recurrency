# Design Doc for P256 Passkey Support

## Table of Contents

- [Design Doc for P256 Passkey Support](#design-doc-for-p256-passkey-support)
  - [Table of Contents](#table-of-contents)
  - [1. Introduction](#1-introduction)
  - [2. Benefits](#2-benefits)
  - [3. Terminology](#3-terminology)
    - [Accounts](#accounts)
    - [Keys](#keys)
    - [Signatures](#signatures)
  - [4.1. Data Flow Diagram](#41-data-flow-diagram)
  - [4.2. Data maps for Legal Teams](#42-data-maps-for-legal-teams)
    - [Web Wallet backend](#web-wallet-backend)
    - [Users Device](#users-device)
  - [5. Specification](#5-specification)
    - [Terms](#terms)
    - [Passkey Transaction Payload](#passkey-transaction-payload)
    - [Passkey Registration](#passkey-registration)
    - [Transaction Submission Specification](#transaction-submission-specification)
    - [Security Considerations](#security-considerations)
      - [General](#general)
      - [Front-end (client)](#front-end-client)
      - [Backend](#backend)
      - [On-chain](#on-chain)
  - [6. Implementation](#6-implementation)
    - [On-chain Implementation](#on-chain-implementation)
      - [Extrinsic verification](#extrinsic-verification)
      - [Signature verification](#signature-verification)
    - [Backend Example Code](#backend-example-code)
      - [Passkey Registration Verification](#passkey-registration-verification)
      - [Transaction Authentication Verification](#transaction-authentication-verification)
  - [7. Options for Discussion](#7-options-for-discussion)
    - [Mortality of `account_sig_passkey_pk` i.e. Account Signature on Passkey Public Key](#mortality-of-account_sig_passkey_pk-ie-account-signature-on-passkey-public-key)
      - [Pros/Cons](#proscons)
    - [Unsigned Extensions vs Extending MultiSignature](#unsigned-extensions-vs-extending-multisignature)
      - [Unsigned Extensions](#unsigned-extensions)
        - [Pros/Cons](#proscons-1)
      - [Extending MultiSignature](#extending-multisignature)
        - [Pros/Cons](#proscons-2)
    - [Generic Key Support](#generic-key-support)
    - [Separate Pallet](#separate-pallet)
  - [8. References](#8-references)

## 1. Introduction

This document outlines the design considerations and specifications for integrating P256 Passkey support for performing transactions on the Frequency chain. Passkey support aims to provide a novel non-custodial solution for managing user accounts and signing transactions on-chain.

## 2. Benefits

- **Non-Custodial Account Management**: Passkey support enables users to interact with the Frequency chain without actual seed access. This reduces the risk of seed exposure and enhances security.

- **Functionality**: Passkey support provides a better user experience by enabling users to sign transactions without seed access. The proliferation of Passkey-enabled services can lead to a seamless user experience.

- **Interoperability**: The use of standard cryptographic protocols (e.g., P256) ensures compatibility with other systems and services that also support these standards. This can facilitate integrations with existing wallets, security modules, and third-party applications.

- **Backup and Recovery**: Passkey support can be used to facilitate account recovery and backup mechanisms. By signing the account Public Key, users can prove ownership of the account and recover access in case of a lost seed.

## 3. Terminology

### Accounts

- **Passkey Account**: The user account associated with the Passkey.
- **Frequency Account**: The account used for on-chain transactions and interactions. This account is derived from a seed phrase generated by the Web Wallet.
- **Web Wallet**: The platform facilitating the management and interaction with user accounts.

### Keys

- **Passkey**: P256 key pair used for transaction signing and account management. This is the primary key used for transaction signing.
- **Passkey Public Key**: The Public Key retrieved from the Passkey registration process.
- **Account Key**: The key pair generated from a seed phrase.
- **Account Public Key**: The Public Key derived from the Account Key.

### Signatures

- **Account signature on Passkey Public Key**: A cryptographic signature generated using the Account Key. The data being signed is the Passkey Public Key. This is used to prove ownership of Account Key.
- **Passkey Signatures**: A cryptographic signature generated using the Passkey private key. This is presented to Passkey enabled services as a challenge-response mechanism. Passkeys are used to generate two signatures as follows:
  - **Signature on Account Public Key**: Passkey signs a message containing the account Public Key. This signature is retained by a Web Wallet platform and/or maybe used for account recovery.
  - **Signature on Transactions**: Passkey signs the transaction payload which needs to be submitted on-chain. This signature is used to verify the authenticity of the transaction.

## 4.1. Data Flow Diagram

- Simplified Registration Diagram
  ![Registration Diagram](../docs/images/Passkey-Registration.png?raw=true)

- Simplified Transaction Diagram
  ![Transaction Diagram](../docs/images/Passkey-Transaction.png?raw=true)

## 4.2. Data maps for Legal Teams

### Web Wallet backend

- Passkey Signature of Account Public Key (`passkey_sig_account_pk`)
- Passkey signature of transaction (`passkey_sig_tx`)
- Frequency Account key signature of Passkey Public Key (`account_sig_passkey_pk`)
- Generated Account Public Key (`account_pk`)
- `credentialPublicKey`: Passkey Public Key (`passkey_pk`)
- `UserName`: User's website-specific username (email, etc...)
- `UserId`: User's website-specific unique ID
- `CredentialId`: The credential's credential ID for the Passkey
- `Counter`: The number of times the authenticator reported it has been used.
- `credentialDeviceType`: Whether this is a single-device or multi-device credential.
- `credentialBackedUp`: Whether or not the multi-device credential has been backed up. Always false for single-device credentials.
- Transaction call

### Users Device

- Keypair for Passkey
- Keypair seed backup for Frequency Account
- All data included in the [Web Wallet backend](#web-wallet-backend) section

## 5. Specification

### Terms

These are the following technical terms and specifications for the implementation of Passkey support on Frequency chain.

- `account_keypair` : A cryptographic key pair generated from a seed phrase
- `account_pk` : Account Public Key
- `passkey_pk` : Passkey Public Key
- `passkey_sig_account_pk` : Signature generated by Passkey on  `account_pk` for Web Wallet backend verification
- `account_sig_passkey_pk` : Signature generated by Account Key on `passkey_pk`
- `passkey_sig_tx` : Signature generated by Passkey on transaction payload, this is required for transaction submission.
- `passkey_authenticator_data` : Authenticator data generated by Passkey, this is required for transaction submission.
- `passkey_client_data` : Client data generated by Passkey, this is required for transaction submission.
- `nonce` : A unique number used to prevent replay attacks.

### Passkey Transaction Payload

- The transaction payload is a structure that contains the following fields:

    ```typescript

    interface PasskeyPayload {
      passkeyPublicKey: `passkey_pk`;
      passkeySignature: `passkey_sig_tx`;
      passkeyAuthenticator: `passkey_authenticator_data`;
      passkeyClientDataJson: `passkey_client_data`;
      passkeyCall: PasskeyCall;
    }

    interface PasskeyCall {
      accountId: `account_pk`;
      accountOwnershipProof: AccountOwnershipProof;
      nonce: `nonce`;
      call: Call;
    }

    interface AccountOwnershipProof {
      Sr25519: account_sig_passkey_pk;
    }
    ```

- The `PasskeyPayload` contains the following fields:
- `passkey_pk` : Passkey Public Key
- `passkeySignature` : Signature generated by Passkey on transaction payload
- `passkeyAuthenticator` : Authenticator data generated by Passkey
- `passkeyClientDataJson` : Client data generated by Passkey
- `passkeyCall` : The actual transaction call that needs to be submitted on-chain.
- `AccountOwnershipProof` : A proof of account ownership generated by the Account Key. This is used to prove ownership of the account.
- `nonce` : A unique number used to prevent replay attacks.

### Passkey Registration

1. **User visits "Wallet Setup Page"**:
   - The browser JavaScript generates a seed phrase, using it to generate `account_keypair` and the corresponding account Public Key (`account_pk`).

2. **Web Wallet requests creation of user Passkey**:
   - A challenge containing the `account_pk` is sent to the Passkey generation process.

3. **Browser JavaScript handles Passkey creation**:
   - The Passkey generation process creates a Passkey and provides the `passkey_pk`.
   - The Passkey signs the `account_pk`, resulting in `passkey_sig_account_pk`.

4. **Browser JavaScript generates a signature using the seed phrase**:
   - `account_keypair` is used to generate a signature on the `passkey_pk`, resulting in `account_sig_passkey_pk`.

      ```javascript
        // Generate Account Key Pair
        const mnemonic = "GENERATE SOME MNEMONIC HERE"
        const keyring = new Keyring({ type: 'sr25519' });
        const account_keypair = keyring.fromMnemonic(mnemonic);
        ...
        ...
        const account_pk = account_keypair.publicKey;

        // Generate Passkey and Sign Account Public Key
        const options = generateRegistrationOptions();
        options.challenge = account_pk;
        const registerPassKey = await SimpleWebAuthnBrowser.startRegistration(options);
        ...
        ...
        // Sign Passkey Public Key using Account Key
        const passkey_sig_account_pk = registerPassKey.signature; // obtained from the registration response
        const passkey_pk = registerPassKey.publicKey; // obtained from the registration response

        // Sign Passkey Public Key using Account Key, this is used to prove ownership of the account
        const account_sig_passkey_pk = account_keypair.sign(passkey_pk);
      ```

5. **Backup options offered to the user**:
   - The user is prompted to download the seed phrase or backup the seed phrase to a secure location.

6. **Browser JavaScript transfers information to Web Wallet Backend**:
   - The following data is sent:
     - `passkey_pk`
     - `account_pk`
     - `account_sig_passkey_pk`
     - `passkey_sig_account_pk`

7. **Web Wallet validates and stores the data**:
   - The backend validates the signatures to ensure ownership and integrity.
   - The backend stores the following:
     - `passkey_pk`
     - `account_pk`
     - `account_sig_passkey_pk`
     - Optionally, `passkey_sig_account_pk` can be stored for account recovery.

### Transaction Submission Specification

Browser/Client receives the following data from the backend:

- `passkey_pk`
- `account_pk`
- `account_sig_passkey_pk`

1. **Transaction Formation**:
   - The client initiates a transaction by providing the details needed for the transaction (e.g., recipient address, amount, nonce).
   - The transaction payload includes the actual tx and proof of account ownership.

    ```javascript
        // Form the transaction payload

        // an example transaction
        const tx = api.tx.balances.transfer(..., ...);

        // Prepare the Passkey payload to be signed by Passkey
        const account_ownership_proof = {
          Sr25519: account_sig_passkey_pk,
        };

        let passkeyCallData = {
          accountId: account_pk,
          accountOwnershipProof: account_ownership_proof,
          call: tx,
        };

        let passkeyCall = api.registry.createType('PalletFrequencyTxPaymentPasskeyCall', passkeyCallData);
    ```

2. **Passkey Signing**:
   - The transaction payload is sent to the Passkey for signing.
   - The Passkey signs the transaction payload using its private key, producing a `passkey_sig_tx`.

    ```javascript

      // Sign the passkeyCall payload using Passkey
      const passkeyTxSignature = await SimpleWebAuthnBrowser.startAssertion({
        challenge: passkeyCall.toU8a(),
        // Additional options
      });

      // The signature generated by Passkey
      passkey_sig_tx = passkeyTxSignature.signature;
      passkey_authenticator_data = passkeyTxSignature.authenticatorData;
      passkey_client_data = passkeyTxSignature.clientData;
      //
    ```

3. **Transaction Submission**:
   - The transaction payload (consisting of `passkey_pk`, `passkey_sig_tx`, `passkey_authenticator_data`, `passkey_client_data`) is submitted to the chain.
   - The transaction is submitted to the chain as an [`unsigned` extrinsic](#unsigned-extensions-vs-extending-multisignature)

    ```javascript
      // Prepare the payload for the Passkey proxy call
      let payload = {
        passkeyPublicKey: Array.from(passkey_pk),
        passkeySignature: Array.from(base64UrlToUint8Array(passkey_sig_tx)),
        passkeyAuthenticator: Array.from(base64UrlToUint8Array(passkey_authenticator_data)),
        passkeyClientDataJson: Array.from(base64UrlToUint8Array(
          passkey_client_data)),
        passkeyCall,
      };

      const passkey_payload = api.createType('PalletFrequencyTxPaymentPasskeyPayload', payload);

      // Submit the transaction to the chain without signature
      const tx = api.tx.{frequecyPassKeyProxy}.submitPasskeyTx(passkey_payload);
      await tx.send()
    ```

4. **Backend Validation and Submission**:
    - The backend can further validate the transaction payload before submitting it to the chain.
    - The backend validates the `passkey_sig_tx` and the `passkey_authenticator_data` to ensure the authenticity of the transaction.
    - For more secure operations, handling the transaction creation and submission on client side is recommended.

### Security Considerations

#### General

- Never store or backup the seed phrase other than memory.
- Prefer more client side data processing and handling, backend should only store the necessary data.
- Choose vetted libraries, npm packages for handling cryptographic operations, such that signing with seed phrase, or handling of private keys is done securely.

#### Front-end (client)

- If key generation is done in front-end, it should ideally being done inside an isolated section such as iframe or Web Worker.
- Generated Keypair should not get stored permanently (except for back up options) and removed as soon as it is not required.

#### Backend

- Passkey registration response should get verified which checks the random challenge. Random Challenge
for registration is generated account Public Key (`account_pk`)
- Passkey Login response should get verified which checks the random challenge
- Passkey Transaction response should get verified which checks transaction related challenge.
- Any provided Frequency account signature should get verified.

#### On-chain

- Preferably using an audited crate to support p256 operations. Currently, we are using `p256` crate
  which is not audited.
  - After investigating other libraries it looks like the only audited alternative is `Openssl` library which is only
a wrapper around the Original C implementation and unfortunately it doesn't look like it is compatible with WASM.
- If signature checks implemented **on_validate** are expensive, then this would open a vulnerability
  surface for DOS attacks.

## 6. Implementation

### On-chain Implementation

#### Extrinsic verification

Currently, the Frequency chain primarily makes use of _SignedExtrinsic_. Every signed extrinsic is validated by a list of SignedExtensions which each verify a different aspect of that extrinsic. The list of signed extensions includes:

- **CheckNonce**: Checks the the nonce inside the payload to avoid replay attacks.
- **ChargeFrqTransactionPayment**: Checks that the transaction fee can be applied to the owner account inside
the payload.

Depending on whether we choose to implement Passkey support using Signed or Unsigned extrinsics, the above extensions may need to be duplicated to check Unsigned extrinsics. Additionally, regardless of which route (signed vs unsigned) we take, we will require the following additional checks:

- **CheckP256Signature**: Verify the P256 signature inside the payload.
- **Others**: We might also need to check the **Era**, **Mortality** and **Genesis hash** if we choose the
unsigned path.

#### Signature verification

- Non-optimal approach

```rust
 pub fn check_passkey_signature(
  payload: &PasskeyPayload<T>,
 ) -> Result<(), TransactionValidityError> {
  // deserialize to COSE key format and check the key
  let cose_key = CoseKey::from_slice(&payload.passkey_public_key[..]);
  let (_, x) = cose_key
   .params
   .iter()
   .find(|(l, _)| l == &Label::Int(-2));
  let (_, y) = cose_key
   .params
   .iter()
   .find(|(l, _)| l == &Label::Int(-3));

  // convert COSE format to P256 verifying key
  let encoded_point =
   EncodedPoint::from_affine_coordinates(
    GenericArray::from_slice(&x.clone().into_bytes()),
    GenericArray::from_slice(&y.clone().into_bytes()),
    false,
   );
  let verify_key = p256::ecdsa::VerifyingKey::from_encoded_point(&encoded_point);

  let passkey_signature =
   p256::ecdsa::DerSignature::from_bytes(&payload.passkey_signature[..]);

  // extract the challenge from client_data and
  // ensure the that the challenge is the same as the call payload
  let client_data: serde_json::Value =
   serde_json::from_slice(&payload.passkey_client_data_json);
  let extracted_challenge = match client_data {
   serde_json::Value::Object(m) => {
    let challenge = m
     .get(&"challenge".to_string());
    if let serde_json::Value::String(base64_url_encoded) = challenge {
     let decoded = base64_url::decode(&base64_url_encoded).map_err(|_| {
      TransactionValidityError::Invalid(InvalidTransaction::Custom(9))
     })?;
     Ok(decoded)
    }
   },
   _ => Err(TransactionValidityError::Invalid(InvalidTransaction::Custom(11))),
  }?;

  let encoded_payload = payload.passkey_call.encode();
  ensure!(
   encoded_payload == extracted_challenge,
   TransactionValidityError::Invalid(InvalidTransaction::Custom(12))
  );

  // prepare signing payload which is [authenticator || sha256(client_data_json)]
  let mut passkey_signature_payload = payload.passkey_authenticator.to_vec();
  passkey_signature_payload.extend_from_slice(&sha2_256(&payload.passkey_client_data_json));

  // finally verify the Passkey signature against the payload
  verify_key
   .verify(&passkey_signature_payload, &passkey_signature)
 }
```

- Some possible optimizations
  - **Compressed Public Key**: Currently passed Public Key is in **Cose** format, and it's between 70-73 bytes.
      If the client is capable of parsing the Cose Public Key, it can extract the compressed encoded key. This process can reduce the size of the Public Key to just 33 bytes.
  - **Challenge data deduplication**: Currently the challenge data is duplicated in `expected_challenge` and
      in it's serialized format inside `passkey_client_data_json`. If the client is able to parse
      `passkey_client_data_json` and replace the `challenge` field value with an empty string, then during the
      signature check we can replace that empty string with `expected_challenge` which would allow us to
      reduce the transaction size by around **40%**. It is important that the order of the field `passkey_client_data_json`  does not change during this operation since that would generate a different signature.
  - **Signing hash of payload**: Since there might be a size limit for the data that can get signed
      via passkeys, it would make sense to only sign the cryptographic hash of the payload. This would also
      reduce the challenge size to only 32 bytes if we decided not to implement the deduplication option.

### Backend Example Code

#### Passkey Registration Verification

```typescript
    // RegistrationResponseJSON is the data that Passkey authenticator returns after registration
    const verification = await verifyRegistrationResponse({
        response: body as RegistrationResponseJSON,
        // challenge that server expects and provided for registration
        expectedChallenge: currentChallenge,
        expectedOrigin: origin,
        expectedRPID: rpID,
        requireUserVerification: true,
    });

    if (verification.verified && verification.registrationInfo) {
        const { credentialPublicKey, credentialID, counter } = verification.registrationInfo;
        const transportsString = JSON.stringify(body.response.transports);
        await credentialService.saveNewCredential(
            loggedInUserId,
            credentialID,
            credentialPublicKey,
            counter,
            transportsString,
        );
    }
```

#### Transaction Authentication Verification

```typescript
    // get AuthenticatorDevice data from database by credentialId
    const dbCredential: AuthenticatorDevice | null = await credentialService.getCredentialByCredentialId(credentialId);
    const authenticator: VerifyAuthenticationResponseOpts["authenticator"] = {
        ...dbCredential,
        credentialID: credentialId,
    };
    const opts: VerifyAuthenticationResponseOpts = {
        response: body,
        expectedChallenge: currentChallenge,
        expectedOrigin: origin,
        expectedRPID: rpID,
        authenticator,
    };
     let verification: VerifiedAuthenticationResponse = await verifyAuthenticationResponse(opts);
    const { verified, authenticationInfo } = verification;

    if (verified) {
        // transaction authentication verification is successful
    }
```

## 7. Options for Discussion

### Mortality of `account_sig_passkey_pk` i.e. Account Signature on Passkey Public Key

#### Pros/Cons

- **Pro**: Mortality of `account_sig_passkey_pk` would ensure that the account signature on the Passkey Public Key is only valid for a certain period, albieit it would be a complex setup.

  >Wil wondered about a mortality as well, but I  have two fears:
  >
  > 1. That people will not backup their other key and forget to regenerate before the deadline.
  > 2. That it adds too much complexity to an already complex setup.

  >In the end, an equal key made the most sense to Wil.

### Unsigned Extensions vs Extending MultiSignature

#### Unsigned Extensions

In this variant we will have an unsigned extrinsic and all the related checks would be done inside
`ValidateUnsigned` trait implementation for the pallet.

##### Pros/Cons

- **Pro**: Faster and already proven implementation
- **Pro**: Flexibility to be replaced with other implementations
- **Con**: Some duplication of code between existing checks on signed extensions and the checks
  implemented on `ValidateUnsigned`
- **Con**: An unsigned extrinsic implementation might open up a new unknown attack vector.

#### Extending MultiSignature

In this variant we will extend `MultiSignature` enum and replace it with a new enum which will have
a new `P256` signature type.

##### Pros/Cons

- **Pro**: No need to use unsigned extrinsic and all extra checks would be done inside a new signed
  extension.
- **Pro**: A uniform and generic solution which would allow having P256 signature scheme to be used
  for other operations on chain.
- **Pro**: This would allow us to use P256 accounts to hold token (but that might not be desirable)
- **Pro**: We could use the P256 keys as MSA control keys.
- **Con**: Requires significant effort (in case if no hard constraints detected) to implement compared to using
  unsigned extension and once deployed there would not be an easy way for a backwards compatible rollback.
  Here is a quick breakdown for known issues:
  - Signature size mismatch force us to implement a new `Signature` type with all required traits.
  - Public Key size mismatch might force us to implement a new `PublicKey` type with all required traits.
  - Reimplementing `MultiSignature`, `MultiSigner` and other types with `P265` functionality added.
  - Adding signature and key generation support on polkadotJS and all frontend implementations
  - Might require DB migration for already stored MultiSignatures

### Generic Key Support

_Question_: Should we be able to use any other key which is already inside a wallet instead
of generating new ones?

There is an issue with the `account_key` generation flow since it would only support transactions
that do not require any Msa account. To be able to use the Passkey feature for the majority of
transactions, it might be better if the `account_key` was already in a wallet and the Msa account
was created for that key,and we register a Passkey using the same.

If an already existing key is allowed to be used with a Passkey the challenge for registering a Passkey
should be a different and random value coming from server instead of the Public Key of mentioned key.

### Separate Pallet

_Question_: Should we implement this feature in a separate pallet or just use already existing `frequency-tx-payment`
pallet?

One argument against having it in a separate pallet is since there is no extra data required to be
stored on-chain, it seems less necessary to split it into a separate pallet.
Another argument in favor of having it in a new pallet is to be able to share this pallet with other
para-chains in the Polkadot ecosystem.

## 8. References

- _**Frontend library for Passkeys**_: https://simplewebauthn.dev/docs/advanced/passkeys
- _**WebAuthn Guide**_: https://webauthn.guide/
- _**WebAuthn spec**_: https://w3c.github.io/webauthn
- _**Cose Key format**_: https://www.iana.org/assignments/cose/cose.xhtml#key-type
